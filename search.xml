<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[树的归纳总结]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%A0%91%E7%9A%84%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概念 树的概念 有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level） 节点的高度 = 节点到叶子节点的最长路径（边数） 节点的深度 = 从根节点出发，到这个节点所需经历的边的个数 节点的层数 = 节点的深度+1 树的高度 = 根节点的高度 二叉树的概念 二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。 有两个比较特殊的二叉树：满二叉树、完全二叉树 满二叉树：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点 完全二叉树：就是我们按顺序给二叉树的节点标号时，1，2，3，4…如果是连在一起的就是完全二叉树，如何标号成1,2,3,5这种就不是完全二叉树 树的话一般使用链式存储法，完全二叉树（其实就是堆）则是用数组存储最节省内存 二叉树的遍历 前面总结了树和二叉树的基本定义，接下来一起来看二叉树中非常重要的操作，二叉树的遍历。我将会用递归和非递归两种方式来归纳以下四种遍历方式的Javascript代码。 前序遍历中序遍历后序遍历层次遍历递归实现1234567function preOrder(root)&#123; if(root)&#123; console.log(root) preOrder(root.left) preOrder(root.right) &#125;&#125; 非递归实现思路：前序遍历为 根-左-右 ，主要任务就是用自己定义的栈来代替系统栈的功能。首先根节点入栈，进入while循环，如果栈不为空，则取出栈顶元素并访问，然后将栈顶元素的左右节点入栈，要注意顺序，右节点先入栈，左节点后入栈。则左节点先出栈，右节点后出栈，符合 根-左-右 的顺序。123456789101112131415function preOrder(root)&#123; if(root)&#123; let stack = [root] //新建栈，并将根结点root入栈 while(stack.length &gt; 0)&#123; //当栈不为空 let topNode = stack.pop() //取栈顶元素 console.log(topNode) //访问 if(topNode.right)&#123; //若右节点存在，入栈 stack.push(topNode.right) &#125; if(topNode.left)&#123; //若左节点存在，入栈 stack.push(topNode.left) &#125; &#125; &#125;&#125; LeetCode对应习题144123456789101112131415161718192021222324252627 / Definition for a binary tree node. function TreeNode(val) &#123; this.val = val; this.left = this.right = null; &#125;// @param &#123;TreeNode&#125; root @return &#123;number[]&#125;*/var preorderTraversal = function(root) &#123; if(!root) return [] let res = [] let stack = [root] while(stack.length &gt; 0)&#123; let node = stack.pop() res.push(node.val) if(node.right)&#123; stack.push(node.right) &#125; if(node.left)&#123; stack.push(node.left) &#125; &#125; return res&#125;;递归实现1234567function inOrder(root)&#123; if(root)&#123; preOrder(root.left) console.log(root) preOrder(root.right) &#125;&#125; 非递归实现思路：中序遍历为 左-根-右 ，首先将游标指向根节点，然后一直向左下遍历并入栈，直到找到最左的。此时再开始回溯，如果栈不为空，则取出栈顶元素并访问，然后将游标指向当前游标位置的右节点，如果右节点为空则无操作，若不为空，则右节点（其实就类似我们最初的根节点了）入栈，并继续按照找最左的方式遍历并入栈，如此往复。直到最终栈为空，进入终态。1234567891011121314151617181920212223242526function inOrder(root)&#123; if(root)&#123; let stack = [] let cursor = root //游标指向根节点 while(stack.length &gt; 0 || cursor)&#123; // 在根节点的左子树遍历完后，根节点出栈并访问，游标指向根节点的右节点时，此时栈是为空的，为了防止遍历停止， // 加上cursor !== null 来判断此时右子树是否为空。若此时仍有右子树，则为真，可继续维持循环的进行。 while(cursor)&#123; //左子树存在，则入栈 stack.push(cursor) cursor = cursor.left &#125; // let node = stack.pop() //取出栈顶元素 // console.log(node) //访问 // if(node.right)&#123; // cursor = node.right // &#125; cursor = stack.pop() res.push(cursor.val) cursor = cursor.right //此处两种写法都可以，但是后者似乎更直观 &#125; &#125;&#125; LeetCode对应习题94123456789101112131415161718192021222324252627/ Definition for a binary tree node. function TreeNode(val) &#123; this.val = val; this.left = this.right = null; &#125;// @param &#123;TreeNode&#125; root @return &#123;number[]&#125;*/var inorderTraversal = function(root) &#123; if(!root) return [] let res = [] let stack = [] let cursor = root while(stack.length &gt; 0 || cursor)&#123; while(cursor)&#123; stack.push(cursor) cursor = cursor.left &#125; cursor = stack.pop() res.push(cursor.val) cursor = cursor.right &#125; return res&#125;;递归实现1234567function postOrder(root)&#123; if(root)&#123; preOrder(root.left) preOrder(root.right) console.log(root) &#125;&#125; 非递归实现思路：前序遍历为 根-左-右 ，而后序遍历为 左-右-根，那么我们只需要交换前序遍历时对左右子树的遍历顺序，则变为 根-右-左，然后再逆序，则为我们需要的后序遍历 左-右-根 啦！12345678910111213141516171819function postOrder(root)&#123; if(root)&#123; let stack1 = [root] //新建栈，并将根结点root入栈 let stack2 = [] while(stack1.length &gt; 0)&#123; //当栈不为空 let topNode = stack1.pop() //取栈顶元素 stack2.push(topNode) //访问 if(topNode.left)&#123; //若左节点存在，入栈 stack1.push(topNode.left) &#125; if(topNode.right)&#123; //若右节点存在，入栈 stack1.push(topNode.right) &#125; &#125; while(stack2.length &gt; 0)&#123; console.log(stack2.pop()) &#125; &#125;&#125; LeetCode对应习题145解法一 双栈法123456789101112131415161718192021222324252627/ Definition for a binary tree node. function TreeNode(val) &#123; this.val = val; this.left = this.right = null; &#125;// @param &#123;TreeNode&#125; root @return &#123;number[]&#125;*/var postorderTraversal = function(root) &#123; if(!root) return [] let res = [] let stack = [root] while(stack.length &gt; 0)&#123; let node = stack.pop() res.push(node.val) if(node.left)&#123; stack.push(node.left) &#125; if(node.right)&#123; stack.push(node.right) &#125; &#125; return res.reverse()&#125;; 解法二 深度优先搜索法（队列）12345678910111213141516171819202122232425/ Definition for a binary tree node. function TreeNode(val) &#123; this.val = val; this.left = this.right = null; &#125;// @param &#123;TreeNode&#125; root @return &#123;number[]&#125;*/var postorderTraversal = function(root) &#123;if (!root) return [];const queue = [root];const res = [];while (queue.length &gt; 0) &#123; const node = queue.shift(); res.unshift(node.val); if (node.left) queue.unshift(node.left); if (node.right) queue.unshift(node.right);&#125;return res;&#125;; 其实还有一种一个栈实现的非递归方法，但是最近有好几个面试，只得加快归纳总结的速度，不能覆盖到了，以后有时间了再补回来吧～使用队列实现思路：队伍先进先出，首先根节点入队，然后进入while循环，若队列不为空，则队列最前端出队并访问，同时将其左右节点依次如队，若为空则无操作，输出结果则为层次遍历～123456789101112131415function levelOrder(root)&#123; if(root)&#123; let queue = [root] //新建队列，并将root入队 while(queue.length &gt; 0)&#123; let top = queue.shift() console.log(top) if(top.left)&#123; queue.push(top.left) &#125; if(top.right)&#123; queue.push(top.right) &#125; &#125; &#125;&#125; LeetCode对应习题102123456789101112131415161718192021222324252627282930313233/ Definition for a binary tree node. function TreeNode(val) &#123; this.val = val; this.left = this.right = null; &#125;// @param &#123;TreeNode&#125; root @return &#123;number[][]&#125;*/var levelOrder = function(root) &#123; if(!root) return [] let res = [] let queue = [root] while(queue.length &gt; 0)&#123; let len = queue.length let current = [] for(let i = 0;i&lt;len;i++)&#123; let node = queue.shift() current.push(node.val) if (node.left) &#123; queue.push(node.left); &#125; if (node.right) &#123; queue.push(node.right); &#125; &#125; res.push(current) &#125; return res&#125; 配套练习题 树的解法中最好优先思考递归的方法，比较容易写。如果对访问速度有要求时，再思考非递归的方式来使用手动实现栈替代系统栈。 一、交换二叉树解法对应于Leetcode 226 Invert Binary Tree 思路：其实就是遍历树的过程，可以用深度遍历（前中后序），或者广度遍历（层次），然后将visit的操作改成交换的操作即可，交换的简便写法是使用ES6的解构赋值 123456789101112131415161718/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;TreeNode&#125; */var invertTree = function(root) &#123; if(!root) return null; [root.left,root.right] = [root.right,root.left]; invertTree(root.left); invertTree(root.right); return root;&#125;; 二、求二叉树的最大深度（按照理解我感觉这里应该叫作最大层数？）解法对应于Leetcode 104 Maximum Depth of Binary Tree 解法一、递归法 思路：从自身到左右孩子之间算上层数差1，之后就是不断递归下去。 123456789101112131415/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxDepth = function(root) &#123; if(!root) return 0 return Math.max(maxDepth(root.left),maxDepth(root.right))+1&#125;; 解法二、BFS 思路：与之前写过的层次遍历代码类似，不再赘述了。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxDepth = function(root) &#123; if(!root) return 0 let res = 0 let queue = [root] while(queue.length &gt; 0)&#123; let len = queue.length for(let i = 0;i&lt;len;i++)&#123; let node = queue.shift() if (node.left) &#123; queue.push(node.left); &#125; if (node.right) &#123; queue.push(node.right); &#125; &#125; res += 1 &#125; return res&#125;; 三、判断是否是二叉搜索树解法对应于Leetcode 98 Validate Binary Search Tree 思路：这个解法挺巧妙的，中序遍历二叉搜索树, 若序列递增, 则说明为二叉搜索树 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var isValidBST = function(root) &#123; if(!root) return true let stack = [] let cursor = root let inorder = - Number.MAX_SAFE_INTEGER while(stack.length &gt; 0 || cursor)&#123; while(cursor)&#123; stack.push(cursor) cursor = cursor.left &#125; cursor = stack.pop() if(cursor.val &lt;= inorder) return false inorder = cursor.val cursor = cursor.right &#125; return true&#125;; 四、二叉树路径和解法对应于Leetcode 112 Path Sum 思路：使用递归的方式，同时对左右子树进行遍历，每一次分叉下去，都会用Sum减掉当前节点的值，之后的节点只需要判断传进来的root是否是叶子节点以及是否等于传进来的Sum即可。这个解法非常巧妙 注意事项：题目中的路径指的是根节点到叶子节点的路径，所以判断时要!root.left &amp;&amp; !root.right来判读是否是叶子节点。 1234567891011121314151617/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; sum * @return &#123;boolean&#125; */var hasPathSum = function(root, sum) &#123; if(!root) return false if(!root.left &amp;&amp; !root.right) return root.val == sum return hasPathSum(root.left,sum - root.val) || hasPathSum(root.right,sum - root.val)&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表归纳总结]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[常见应用场景：一些缓存场景，如LRU缓存淘汰算法 单链表升级版：双向链表、循环链表 小技巧 技巧一：利用哨兵（头节点）简化实现难度 如果我们要在链表中进行插入操作时，当链表为空时和当链表不为空时，操作是不同的。如果我们要在链表中进行删除操作时，当要删除的节点是最末节点时和当要删除的节点不是最末节点时，操作是不同的。针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错，使用哨兵（头节点）可以帮助我们统一操作。如果我们引入哨兵结点，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。 技巧二：重点留意边界条件处理 如果链表为空时，代码是否能正常工作？ 如果链表只包含一个结点时，代码是否能正常工作？ 如果链表只包含两个结点时，代码是否能正常工作？ 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？ 技巧三：举例画图，辅助思考 配套练习题一、单链表反转解法对应于Leetcode 206 单链表反转 思路：在遍历单链表的同时反转指针，从而达到使单链表逆序的功能。 注意事项：要在纸上简单画一下过程，理顺一下每一步的顺序，不要丢失指针即可。 方法：首先新建null节点为node，并让一个游标cursor指向head，因为我们需要反转指针，cursor.next = node如果先执行了的话，就会造成丢失指针，故需要有一个临时的nextNode保存当前处理节点的下一个节点，并在最后使得cursor = nextNode 123456789101112131415161718192021222324// Input: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL// Output: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; NULL/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123; let node = null let cursor = head while (cursor != null) &#123; let nextNode = cursor.next cursor.next = node node = cursor cursor = nextNode &#125; return node&#125;; 二、链表中环的检测解法对应于Leetcode 141 链表中环的检测 解法一、快慢指针法 思路：快指针跑在前头，慢指针在后，如果存在环的话，快指针就一定能追上慢指针。 注意事项：while的条件，因为快指针跑的快，所以主要是判断fast的临界。只有当fast和fast.next均不为null时，才不会发生TypeError: Cannot read property &#39;next&#39; of null之类的错误 123456789101112131415161718192021222324// Input: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL// Output: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; NULL/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123; let node = null let cursor = head while (cursor != null) &#123; let nextNode = cursor.next cursor.next = node node = cursor cursor = nextNode &#125; return node&#125;; 解法二、Set集合映射法 思路：新建一个Set，遍历链表，判断Set是否含有当前处理的节点，若有，说明之前已经遇到过，有环。否则就说明是新的节点，那么就add到Set中，然后继续下一个节点 1234567891011121314151617181920212223/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function (head) &#123; let set = new Set() while (head != null) &#123; if (set.has(head)) &#123; return true &#125; set.add(head) head = head.next &#125; return false&#125;; 三、两个有序的链表合并解法对应于Leetcode 21 两个有序的链表合并 解法一、新建链表法 思路：新的链使用哨兵guard，然后l1与l2反复比较头节点大小，小的就摘除，接到新的链后面。相等的话就l1先l2后，都接到新的链后面。当其中一条链为空，就把另外一条链剩下的都接到新链后即可。 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function (l1, l2) &#123; if (!l1) return l2 if (!l2) return l1 let guard = new ListNode(null) let cursor = guard while (l1 &amp;&amp; l2) &#123; if (l1.val &lt; l2.val) &#123; cursor.next = l1 l1 = l1.next &#125; else if (l1.val &gt; l2.val) &#123; cursor.next = l2 l2 = l2.next &#125; else &#123; cursor.next = l1 l1 = l1.next cursor = cursor.next cursor.next = l2 l2 = l2.next &#125; cursor = cursor.next &#125; cursor.next = l1 || l2 return guard.next&#125;; 解法二、原地合并法（递归） 递归指的是把问题分解成为规模更小的、 具有与原问题有着相同解法的问题。 递归特性一： 必须有一个明确的结束条件 递归特性二： 每次递归都是为了让问题规模变小 递归特性三：层次过多会导致栈溢出， 且效率不高 思路：使用递归的方法，明确结束条件是当其中一条链为空时，递归就会结束。每次递归都使得head所在的链少一个节点，进而使问题规模变小 1234567891011121314151617181920212223/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function (l1, l2) &#123; if (!l1) return l2 if (!l2) return l1 let head = l1.val &lt; l2.val ? l1 : l2 let left = l1.val &lt; l2.val ? l2 : l1 head.next = mergeTwoLists(head.next, left) return head&#125;; 四、删除链表倒数第 n 个结点解法对应于Leetcode 19 删除链表倒数第 n 个结点 解法一、快慢指针法 - （一趟搞定） 思路：为了方便处理只有一个节点的情况，我们引入头指针guard。让快慢指针fast &amp; slow均指向guard，然后看传入的n的值，n为多少，则快指针就先走几步，由于我们引入了头节点，所以快指针相应的要多走一步，故为n+1。接下来就是快慢指针同时往后走，直到快指针走到头。我们画图可以发现，当前的slow处于待删除节点的前方，我们接下来就使用slow.next = slow.next.next即可删除对应的节点了，之后再返回头指针的next即可。 注意事项：引入头指针后，fast应先走n+1步。做链表题一定要同时画一画草图，思路更清晰 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; n * @return &#123;ListNode&#125; */var removeNthFromEnd = function (head, n) &#123; let guard = new ListNode(null) guard.next = head let fast = guard let slow = guard for (let i = 0; i &lt; n + 1; i++) &#123; fast = fast.next &#125; while (fast) &#123; fast = fast.next slow = slow.next &#125; slow.next = slow.next.next return guard.next&#125;; 解法二、快慢指针法 - （两趟搞定） 思路：同样的，哨兵guard头节点是为了处理只有一个节点时的特殊情况。第一遍先从头遍历完链表，计算出从head走到链表结尾需要的步数length。然后用length-n算出从head要到倒数第n个节点前需要的步数。那么如果是从guard开始走length - n步就可以走到待删除节点的前面，然后使用cursor.next = cursor.next.next即可 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; n * @return &#123;ListNode&#125; */var removeNthFromEnd = function (head, n) &#123; let guard = new ListNode(null) guard.next = head let cursor = head let length = 0 while (cursor) &#123; length++ cursor = cursor.next &#125; cursor = guard length -= n while (length) &#123; length-- cursor = cursor.next &#125; cursor.next = cursor.next.next return guard.next&#125;; 五、求链表的中间结点解法对应于Leetcode 876 求链表的中间结点 解法一、快慢指针法 思路：这个很简单，就没什么好说的了。 1234567891011121314151617181920/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var middleNode = function (head) &#123; let fast = head let slow = head while (fast &amp;&amp; fast.next) &#123; fast = fast.next.next slow = slow.next &#125; return slow&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2019%2F03%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[第一篇文章，还是挺有纪念意义的hhh其实我想有一个自己的博客好久了，但是一直都想的是自己用Vue或React写前端，用Koa或者Express之类的写个后台也因为想的这么复杂，所以学习速度也跟不上，迟迟没把博客搭起来现在准备春招秋招，还是需要有一个存放知识归纳文章的地方，索性就用Github Pages + Hexo解决了，感觉也挺好希望你喜欢这个博客，并能从中有所收获。如有错误的地方，也请批评指正]]></content>
      <categories>
        <category>胡言乱语</category>
      </categories>
  </entry>
</search>
