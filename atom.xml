<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonLam&#39;s Blog</title>
  
  <subtitle>Just Enjoy It!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="JasonLam0990.github.io/"/>
  <updated>2019-03-16T00:55:23.129Z</updated>
  <id>JasonLam0990.github.io/</id>
  
  <author>
    <name>JasonLam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单链表归纳总结</title>
    <link href="JasonLam0990.github.io/2019/03/16/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>JasonLam0990.github.io/2019/03/16/单链表归纳总结/</id>
    <published>2019-03-15T16:15:23.000Z</published>
    <updated>2019-03-16T00:55:23.129Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p>常见应用场景：一些缓存场景，如LRU缓存淘汰算法</p></div><div class="note primary"><p>单链表升级版：双向链表、循环链表</p></div><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ul><li><h3 id="技巧一：利用哨兵（头节点）简化实现难度"><a href="#技巧一：利用哨兵（头节点）简化实现难度" class="headerlink" title="技巧一：利用哨兵（头节点）简化实现难度"></a>技巧一：利用哨兵（头节点）简化实现难度</h3></li></ul><blockquote><p>如果我们要在链表中进行插入操作时，当链表为空时和当链表不为空时，操作是不同的。如果我们要在链表中进行删除操作时，当要删除的节点是最末节点时和当要删除的节点不是最末节点时，操作是不同的。<br><br>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错，使用哨兵（头节点）可以帮助我们统一操作。<br><br>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。<br><br>因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。</p></blockquote><ul><li><h3 id="技巧二：重点留意边界条件处理"><a href="#技巧二：重点留意边界条件处理" class="headerlink" title="技巧二：重点留意边界条件处理"></a>技巧二：重点留意边界条件处理</h3></li></ul><blockquote><ul><li>如果链表为空时，代码是否能正常工作？ </li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul></blockquote><ul><li><h3 id="技巧三：举例画图，辅助思考"><a href="#技巧三：举例画图，辅助思考" class="headerlink" title="技巧三：举例画图，辅助思考"></a>技巧三：举例画图，辅助思考</h3></li></ul><h2 id="配套练习题"><a href="#配套练习题" class="headerlink" title="配套练习题"></a>配套练习题</h2><h3 id="一、单链表反转"><a href="#一、单链表反转" class="headerlink" title="一、单链表反转"></a>一、单链表反转</h3><div class="note info"><p>解法对应于Leetcode 206 单链表反转</p></div><ul><li><p>思路：在遍历单链表的同时反转指针，从而达到使单链表逆序的功能。</p></li><li><p>注意事项：要在纸上简单画一下过程，理顺一下每一步的顺序，不要丢失指针即可。</p></li><li><p>方法：首先新建null节点为node，并让一个游标cursor指向head，因为我们需要反转指针，cursor.next = node如果先执行了的话，就会造成丢失指针，故需要有一个临时的nextNode保存当前处理节点的下一个节点，并在最后使得cursor = nextNode</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span></span><br><span class="line"><span class="comment">// Output: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; NULL</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> cursor = head</span><br><span class="line">    <span class="keyword">while</span> (cursor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextNode = cursor.next</span><br><span class="line">        cursor.next = node</span><br><span class="line">        node = cursor</span><br><span class="line">        cursor = nextNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二、链表中环的检测"><a href="#二、链表中环的检测" class="headerlink" title="二、链表中环的检测"></a>二、链表中环的检测</h3><div class="note info"><p>解法对应于Leetcode 141 链表中环的检测</p></div><h4 id="解法一、快慢指针法"><a href="#解法一、快慢指针法" class="headerlink" title="解法一、快慢指针法"></a>解法一、快慢指针法</h4><ul><li><p>思路：快指针跑在前头，慢指针在后，如果存在环的话，快指针就一定能追上慢指针。</p></li><li><p>注意事项：while的条件，因为快指针跑的快，所以主要是判断fast的临界。只有当fast和fast.next均不为null时，才不会发生<code>TypeError: Cannot read property &#39;next&#39; of null</code>之类的错误</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span></span><br><span class="line"><span class="comment">// Output: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; NULL</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> cursor = head</span><br><span class="line">    <span class="keyword">while</span> (cursor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextNode = cursor.next</span><br><span class="line">        cursor.next = node</span><br><span class="line">        node = cursor</span><br><span class="line">        cursor = nextNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法二、Set集合映射法"><a href="#解法二、Set集合映射法" class="headerlink" title="解法二、Set集合映射法"></a>解法二、Set集合映射法</h4><ul><li>思路：新建一个Set，遍历链表，判断Set是否含有当前处理的节点，若有，说明之前已经遇到过，有环。否则就说明是新的节点，那么就add到Set中，然后继续下一个节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">    while (head != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">set</span>.has(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>.add(head)</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三、两个有序的链表合并"><a href="#三、两个有序的链表合并" class="headerlink" title="三、两个有序的链表合并"></a>三、两个有序的链表合并</h3><div class="note info"><p>解法对应于Leetcode 21 两个有序的链表合并</p></div><h4 id="解法一、新建链表法"><a href="#解法一、新建链表法" class="headerlink" title="解法一、新建链表法"></a>解法一、新建链表法</h4><ul><li>思路：新的链使用哨兵guard，然后l1与l2反复比较头节点大小，小的就摘除，接到新的链后面。相等的话就l1先l2后，都接到新的链后面。当其中一条链为空，就把另外一条链剩下的都接到新链后即可。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">let</span> guard = <span class="keyword">new</span> ListNode(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">let</span> cursor = guard</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            cursor.next = l1</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">            cursor.next = l2</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cursor.next = l1</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">            cursor.next = l2</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = cursor.next</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.next = l1 || l2</span><br><span class="line">    <span class="keyword">return</span> guard.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法二、原地合并法（递归）"><a href="#解法二、原地合并法（递归）" class="headerlink" title="解法二、原地合并法（递归）"></a>解法二、原地合并法（递归）</h4><ul><li>递归指的是把问题分解成为规模更小的、 具有与原问题有着相同解法的问题。</li></ul><blockquote><ul><li>递归特性一： 必须有一个明确的结束条件</li><li>递归特性二： 每次递归都是为了让问题规模变小</li><li>递归特性三：层次过多会导致栈溢出， 且效率不高</li></ul></blockquote><ul><li>思路：使用递归的方法，明确结束条件是当其中一条链为空时，递归就会结束。每次递归都使得head所在的链少一个节点，进而使问题规模变小</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> head = l1.val &lt; l2.val ? l1 : l2</span><br><span class="line">    <span class="keyword">let</span> left = l1.val &lt; l2.val ? l2 : l1</span><br><span class="line"></span><br><span class="line">    head.next = mergeTwoLists(head.next, left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="四、删除链表倒数第-n-个结点"><a href="#四、删除链表倒数第-n-个结点" class="headerlink" title="四、删除链表倒数第 n 个结点"></a>四、删除链表倒数第 n 个结点</h3><div class="note info"><p>解法对应于Leetcode 19 删除链表倒数第 n 个结点</p></div><h4 id="解法一、快慢指针法-（一趟搞定）"><a href="#解法一、快慢指针法-（一趟搞定）" class="headerlink" title="解法一、快慢指针法 - （一趟搞定）"></a>解法一、快慢指针法 - （一趟搞定）</h4><ul><li><p>思路：为了方便处理只有一个节点的情况，我们引入头指针guard。让快慢指针fast &amp; slow均指向guard，然后看传入的n的值，n为多少，则快指针就先走几步，由于我们引入了头节点，所以快指针相应的要多走一步，故为n+1。接下来就是快慢指针同时往后走，直到快指针走到头。我们画图可以发现，当前的slow处于待删除节点的前方，我们接下来就使用slow.next = slow.next.next即可删除对应的节点了，之后再返回头指针的next即可。</p></li><li><p>注意事项：引入头指针后，fast应先走n+1步。做链表题一定要同时画一画草图，思路更清晰</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span> (<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> guard = <span class="keyword">new</span> ListNode(<span class="literal">null</span>)</span><br><span class="line">    guard.next = head</span><br><span class="line">    <span class="keyword">let</span> fast = guard</span><br><span class="line">    <span class="keyword">let</span> slow = guard</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        fast = fast.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next</span><br><span class="line">    <span class="keyword">return</span> guard.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法二、快慢指针法-（两趟搞定）"><a href="#解法二、快慢指针法-（两趟搞定）" class="headerlink" title="解法二、快慢指针法 - （两趟搞定）"></a>解法二、快慢指针法 - （两趟搞定）</h4><ul><li>思路：同样的，哨兵guard头节点是为了处理只有一个节点时的特殊情况。第一遍先从头遍历完链表，计算出从head走到链表结尾需要的步数length。然后用length-n算出从head要到倒数第n个节点前需要的步数。那么如果是从guard开始走length - n步就可以走到待删除节点的前面，然后使用cursor.next = cursor.next.next即可</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span> (<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> guard = <span class="keyword">new</span> ListNode(<span class="literal">null</span>)</span><br><span class="line">    guard.next = head</span><br><span class="line">    <span class="keyword">let</span> cursor = head</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (cursor) &#123;</span><br><span class="line">        length++</span><br><span class="line">        cursor = cursor.next</span><br><span class="line">    &#125;</span><br><span class="line">    cursor = guard</span><br><span class="line">    length -= n</span><br><span class="line">    <span class="keyword">while</span> (length) &#123;</span><br><span class="line">        length--</span><br><span class="line">        cursor = cursor.next</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.next = cursor.next.next</span><br><span class="line">    <span class="keyword">return</span> guard.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="五、求链表的中间结点"><a href="#五、求链表的中间结点" class="headerlink" title="五、求链表的中间结点"></a>五、求链表的中间结点</h3><div class="note info"><p>解法对应于Leetcode 876 求链表的中间结点</p></div><h4 id="解法一、快慢指针法-1"><a href="#解法一、快慢指针法-1" class="headerlink" title="解法一、快慢指针法"></a>解法一、快慢指针法</h4><ul><li>思路：这个很简单，就没什么好说的了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> middleNode = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head</span><br><span class="line">    <span class="keyword">let</span> slow = head</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      把单链表的相关知识捋了一下，做了一点总结，同时也刷了一些题目，在此做一些记录，方便以后查阅。
    
    </summary>
    
      <category term="数据结构与算法" scheme="JasonLam0990.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="单链表" scheme="JasonLam0990.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello Blog</title>
    <link href="JasonLam0990.github.io/2019/03/15/hello-world/"/>
    <id>JasonLam0990.github.io/2019/03/15/hello-world/</id>
    <published>2019-03-15T02:03:48.000Z</published>
    <updated>2019-03-15T16:13:03.340Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>第一篇文章，还是挺有纪念意义的hhh<br>其实我想有一个自己的博客好久了，但是一直都想的是自己用Vue或React写前端，用Koa或者Express之类的写个后台<br>也因为想的这么复杂，所以学习速度也跟不上，迟迟没把博客搭起来<br>现在准备春招秋招，还是需要有一个存放知识归纳文章的地方，索性就用Github Pages + Hexo解决了，感觉也挺好<br>希望你喜欢这个博客，并能从中有所收获。如有错误的地方，也请批评指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;第一篇文章，还是挺有纪念意义的hhh&lt;br&gt;其实我想有一个自己的博客好久了，但是一直都想的是自己用Vue或React写前端，用Koa或者Express之类的写个后台&lt;br&gt;也因为想的这么复杂，所以学
      
    
    </summary>
    
      <category term="胡言乱语" scheme="JasonLam0990.github.io/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
    
  </entry>
  
</feed>
